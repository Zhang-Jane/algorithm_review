# 基本的概念和术语

## 1.什么是数据?

数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并且输入给计算机处理的符号的集合

## 2.数据元素

是组成数据的基本单位

## 3.数据项

一个数据元素可以由若干个数据项组成，且数据项是数据不可分割的最小单位

## 4.数据对象

是性质相同的数据元素的集合，是数据的子集

## 5.数据结构

是相互之间存在一种或多种特定关系的数据元素的集合

# 数据结构的结构

## 1.根据逻辑角度分类（数据对象之间的相互关系）

- 集合结构
    - 数据对象中数据之间除了同属于一个集合外,他们之间没有任何的关系
- 线性结构
    - 数据结构中的数据元素之间是一对一的关系
- 树形结构
    - 数据元素之间是一对多的层次关系
- 图形结构
    - 数据元素之间是多对多的关系

## 2.根据物理角度分类（计算机中存储的形式）

- 顺序存储结构
    - 把数据元素放在地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的
- 链式存储结构
    - 把数据存放在任意的位置存储单元中，这组存储单元可以是连续，也可以不连续，通过指针反应对应的逻辑关系

![](/imgs/数组和链表内存的分配方式.png)

# 线性表

在实际的运用中，线性表都是以栈，队列，字符串，数组的等特殊的线性表的形式来使用

## 1.顺序存储结构

### 基本的操作

**1.计算顺序表的长度length，下标index从0开始到len-1**

**2.计算指定数据的下标index**

**3.插入或者删除数据，开头插入（删除）或者中间插入（删除），数据需要往后移动，末尾插入（删除）不需要**

![](/imgs/数组的插入.png)	

- 插入数组元素的操作存在3种情况。
  - 尾部插入
  - 中间插入（需要元素向后移动）
  - 超范围插入
- 删除
  - 尾部删除
  - 其他位置删除（需要元素向后移动）

**4.数据通过下标index查找，涉及查找的效率，引申出各种的查找算法**

**5.数组的扩容**

## 2.链式存储结构

常见的链表：

- 单链表
- 静态链表
- 循环链表
- 双向链表



链表的插入节点：

- 尾部插入

![](/imgs/链表的尾部插入.png)

- 头部插入

![](/imgs/链表的头部插入.png)

- 中间插入

![](/imgs/链表的中间插入.png)

链表的删除：

- 尾部删除

![](/imgs/链表的尾部删除.png)

- 头部删除

![](/imgs/链表的头部删除.png)

- 中间删除

![](/imgs/链表的中部删除.png)

# 栈

栈的最大特点就是后进先出（LIFO）。对于栈中的数据来说，所有操作都是在栈的顶部完成的，只可以查看栈顶部的元素，只能够向栈的顶部压⼊数据，也只能从栈的顶部弹出数据。 

![](/imgs/栈.png)

## 作用（栈的输出顺序和输入顺序相反）

### 1. 递归的逻辑

### 2. 四则运算

`9 + (3-1) x 3 + 10 ÷ 2`  -> `9 3 1 - 3 * + 10 2 / +`（后缀表达式）

转换的规则：

从左到右遍历表达式中的每个数字和字符，若是数字就输出，若是符号就先判断与栈定符号的优先级，是右括号（`)`）或者优先级低于栈顶的符号则栈顶的元素依次出栈并输出，并将当前符号进栈，一直到最后全部输出

计算四则运算：（从左到右遍历表达式中的每个数字和字符，若是数字就进栈，遇到符号，就把俩个栈顶的数字出栈，然后计算，再把结果入栈）

1. 初始化一个空的栈
2. 把数字进栈
3. 遇到符号，弹出2个数字
4. 计算结果，再入栈

# 队列

和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在**队尾查看和添加数据，在队头查看和删除数据。**

队列的出口端叫作队头 （front）

出队操作（dequeue）就是把元素移出队列，只允许在队头一侧移出元
素，**出队元素的后一个元素将会成为新的队头**

![](/imgs/出队列.png)

队列的入口端叫作队尾 （rear）

入队（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，**新元素的下一个位置将会成为新的队尾**

## 循环队列

假设一个队列经过反复的入队和出队操作，还剩下2个元素，在“物理”上分布于数组的末尾位置。这时又有一个新元素将要入队。

在数组不做扩容的前提下，如何让新元素入队并确定新的队尾位置呢？

我们可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。这样一来，整个队列的元素就“循环”起来了。在物理存储上，队尾的位置也可以在队头之前。

当再有元素入队时，将其放入数组的首位，队尾指针继续后移即可。一直到（队尾下标+1）%数组长度 = 队头下标时，代表此队列真的已
经满了。需要注意的是，**队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1**。

![](/imgs/循环队列.png)

## 作用（栈的输出顺序和输入顺序相反）

# 树

![](/imgs/树的基本结构.png)

## 树一些重要的概念

- **节点的度：一个节点含有的子树的个数称为该节点的度；**
- **树的度：一棵树中，最大的节点的度称为树的度；**
- **叶节点或终端节点：度为零的节点；**
- **非终端节点或分支节点：度不为零的节点；**
- **父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；**
- **孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；**
- **兄弟节点：具有相同父节点的节点互称为兄弟节点；**
- **节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；**
- **深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；**
- **高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；**
- **堂兄弟节点：父节点在同一层的节点互为堂兄弟；**
- **节点的祖先：从根到该节点所经分支上的所有节点；**
- **子孙：以某节点为根的子树中任一节点都称为该节点的子孙。**
- **森林：由m（m>=0）棵互不相交的树的集合称为森林；**

## 树的种类

- 无序树
    树的任意节点的子节点没有顺序关系。
- 有序树
    树的任意节点的子节点有顺序关系。
- 二叉树
    树的任意节点至多包含两棵子树。![](/imgs/二叉树.png)


- 满二叉树
    叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。![](/imgs/满二叉树.png)

- 完全二叉树
    对于一颗二叉树，假设其深度为d（d>1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；完全二叉树只需保证最后一个节点之前的节点都齐全即可。

    PS：这里的满二叉树和完全二叉树取的是国内的定义，国外的定义不一样，有兴趣的可以去看看国外的定义。![](/imgs/完全二叉树.png)

- 平衡二叉树（AVL）
    它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。

- 二叉查找树（二叉搜索树、BST（binary search tree） ）
    若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
    若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
    任意节点的左、右子树也分别为二叉查找树；
    没有键值相等的节点。

特点：

1.中序遍历的结果是有序的

2.最左侧的叶子节点的值是最小值，最右侧的叶子节点的值是最大值

有个新问题：二叉查找树中依次插入9、8、7、6、5、4，二叉查找树退化成链条

![](/imgs/二叉查找树退化成链条.png)

- 霍夫曼树
    带权路径最短的二叉树称为哈夫曼树或最优二叉树。

- 红黑树
    **红黑树是一颗特殊的二叉查找树**，除了二叉查找树的要求外，它还具有以下特性：

    每个节点或者是黑色，或者是红色。
    根节点是黑色。
    每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
    如果一个节点是红色的，则它的子节点必须是黑色的。
    从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

- B-tree（B-树或者B树）
    一颗m阶B树的特性：

    根结点至少有两个子女（如果B树只有一个根节点，这个根节点的key的数量可以为[1~m-1]）
    每个非根节点所包含的关键字个数 j 满足：⌈m/2⌉ - 1 <= j <= m - 1，节点的值按非降序方式存放，即从左到右依次增加
    除根结点以及叶子节点以外的所有结点的度数正好是关键字总数加1，故内部节点的子树个数 k 满足：⌈m/2⌉ <= k <= m
    所有的叶子结点都位于同一层

- B+树
    m阶B+树是m阶B-tree的变体，它的定义大致跟B-tree一致，不过有以下几点不同：

    有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点，其中⌈m/2⌉ <= n <= m
    所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
    所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字
    通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点

- B*树

    B*树是B+树的变体，除了B+树的要求之外，还有以下特性：

    - ⌈m*2/3⌉ <= n <=m 这里的n是除根节点之外的内部节点的键
    - 增加内部节点中兄弟节点的指针，由左边指向右边

- 字典树

    根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。

    - 利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高
    - 给出一些单词，（`and`，`as`，`at`，`cn`，`com`）

    ![img](https://upload-images.jianshu.io/upload_images/17671508-f2c97301c9010d14?imageMogr2/auto-orient/strip|imageView2/2/w/440/format/webp)

    ```java
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;

    public class TrieTree {
        private Node root = new Node();

        public void putAll(String... words) {
            putAll(Arrays.asList(words));
        }

        public void putAll(List<String> words) {
            words.stream().forEach(this::put);
        }

        public void put(String word) {
            Node node = root;
            for (int i = 0; i < word.length(); i++) {
                char ch = word.charAt(i);
                Node next = node.addNextIfAbsent(ch);
                node = next;
            }
            node.markEnd();
        }

        public boolean contains(String text) {
            for (int i = 0; i < text.length(); ++ i) {
                if (contains(text, i, text.length())) {
                    return true;
                }
            }
            return false;
        }

        private boolean contains(String word, int left, int right) {
            Node node = root;
            for (int i = left; i < right; i++) {
                char ch = word.charAt(i);
                Node next = node.findNext(ch);

                if (next == null) {
                    return false;
                }
                if (next.isEnd()) {
                    return true;
                }

                node = next;
            }
            return false;
        }

        private static class Node {
            private Map<Character, Node> children;
            private boolean end;

            public Node() {
                children = new HashMap<>();
                end = false;
            }

            public Node findNext(char ch) {
                return this.children.get(ch);
            }

            public Node addNextIfAbsent(char ch) {
                Node next = findNext(ch);
                if (next == null) {
                    next = new Node();
                    this.children.put(ch, next);
                }
                return next;
            }

            public boolean isEnd() {
                return this.end;
            }

            public void markEnd() {
                this.end = true;
            }
        }
    }
    public class TrieDemo {
        public static void main(String[] args) {
            TrieTree trieTree = new TrieTree();
            trieTree.putAll("素人", "huhu");

            System.out.println(trieTree.contains("aaa素人bbb")); // true
            System.out.println(trieTree.contains("aaabbb")); // false
        }
    }
    /*
    如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。
    如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。
    */
    ```

    ​

# 二叉树（十分重点）

![](/imgs/二叉树的基本模型.png)

从节点之间位置关系的角度来看，二叉树的遍历分为4种。

1. 前序遍历。
2. 中序遍历。
3. 后序遍历。
4. 层序遍历。

从更宏观的角度来看，二叉树的遍历归结为两大类。

1. 深度优先遍历 （前序遍历、中序遍历、后序遍历）。
2. 广度优先遍历 （层序遍历）。

## 前序遍历

二叉树的前序遍历，输出顺序是根节点、左子树、右子树。

![](/imgs/二叉树的前序遍历.png)



## 中序遍历

二叉树的中序遍历，输出顺序是左子树、根节点、右子树。

![](/imgs/二叉树中序遍历.png)

## 后序遍历

二叉树的后序遍历，输出顺序是左子树、右子树、根节点

![](/imgs/二叉树的后序遍历.png)

## 层序遍历

二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。

![](/imgs/二叉树的层序遍历.png)

# 堆

https://writings.sh/post/data-structure-heap-and-common-problems

- 最小堆：所有父亲节点不比其孩子节点的值大的完全二叉树。
- 最大堆：所有父亲节点不比其孩子节点的值小的完全二叉树。

![](/imgs/min-heap-and-max-heap.jpeg)

二叉树的数组表示：

用数组表示时，有如下性质：

- 下标是 `i` 的节点的左右孩子节点的下标是 `2i+1` 和 `2i+2`
- 下标是 `i` 的节点的父节点的下标是 `(i-1)/2` （向下取整）

![](/imgs/heap-array-representation.jpeg)

## 二叉堆的自我调整

二叉堆，有如下几种操作。

1. 插入节点。
2. 删除节点。
3. 构建二叉堆。

### 最小堆的操做

#### 插入和上浮

向一个最小堆插入元素：

1. 追加新元素到数组尾部。
2. 从新元素处进行堆上浮。

上浮，是指当前元素不断和父节点比较大小：

1. 如果父节点更大，则父子交换。
2. 否则，满足最小堆性质，停止交换

![](/imgs/heap-push-siftup-1.jpeg)

#### 删除和下沉

从一个最小堆中删除头部元素：

1. 尾节点覆盖顶节点，堆大小减一。
2. 从顶节点处进行堆下沉。

下沉，是指当前元素不断和两个孩子节点比较大小：

1. 如果它比两个孩子节点的值都小，则和更小的孩子交换。
2. 否则，满足最小堆性质，停止交换。

![](/imgs/heap-pop-siftdown-1.jpeg)

## 构建二叉堆

把一个无序的完全二叉树调整为二叉堆

常见的方式有两种：

- 自顶向下的上浮。
- 自底向上的下沉。

![](/imgs/build_bin_heap.png)

## 应用

- topK的问题
- 优先队列

# 总结

**数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）**。数据结构最终形式都是使用数组和链表。

比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。

「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。

「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。

「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。



**数组**由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

**链表**因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。