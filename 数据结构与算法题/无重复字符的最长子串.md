给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。

     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

这道题主要用到思路是：滑动窗口

什么是滑动窗口？

其实就是一个队列, 比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

``` text
以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；
以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；
以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；
以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb；
以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；
以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；
以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；
以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。
```

时间复杂度：O(n)

滑动解决1：

``` python
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        left = 0 # 滑动的偏移量
        curr_len = 0 # 当前的子串的长度
        max_len = 0 # 最大子串的长度
        dup_set = set() # 去重
        for i in s:
            curr_len += 1
            while i in dup_set: # 注意为什么要用while，不用if。因为从set中移除的是遇到重复元素时，之前所有的存在集合中的值
                dup_set.remove(s[left])
                left += 1
                curr_len -= 1
            if curr_len > max_len:
                max_len = curr_len
            dup_set.add(i)
        return max_len

s = Solution().lengthOfLongestSubstring("abbbaacc")
print(s)
```

滑动解决2：

定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
我们定义不重复子串的开始位置为 start，结束位置为 end
随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
无论是否更新 start，都会更新其 map 数据结构和结果 ans。
时间复杂度：O(n)

``` bash
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        maxL, start, end = 0, 0, 0 # maxL表示最大的子串长度，start，end表示移动的区间
        maps = {}
        for i in s:
            end += 1
            maps[i] = maps.get(i, 0) + 1
            while maps[i] > 1:
                maps[s[start]] -= 1
                start += 1
            maxL = max(maxL, end-start)
        return maxL

s = Solution().lengthOfLongestSubstring("bbadacdbwc")
print(s)
```

总结滑动思路：

第一种和第二种实际是一样的，只是一个是利用的set一个是用dict。
